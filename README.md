# COMPILER-DESIGN-Projct 

**PhaseI
Suppose your lexical analyzer is in the executable named lexer. Then for the MINI-L program fibonacci.min, your lexical analyzer should be invoked as follows:

cat fibonacci.min | lexer

function fibonacci;
beginparams
	k : integer;
endparams
beginlocals
endlocals
beginbody
	if (k <= 1) then return 1; endif;
	return fibonacci(k - 1) + fibonacci(k - 2);
endbody

function main;
beginparams
endparams
beginlocals
	n : integer;
	fib_n : integer;
endlocals
beginbody
	read n;
	fib_n := fibonacci(n);
	write fib_n;
endbody

FUNCTION
IDENT fibonacci
SEMICOLON
BEGIN_PARAMS
IDENT k
COLON
INTEGER
SEMICOLON
END_PARAMS
BEGIN_LOCALS
END_LOCALS
BEGIN_BODY
IF
L_PAREN
IDENT k
LTE
NUMBER 1
R_PAREN
THEN
RETURN
NUMBER 1
SEMICOLON
ENDIF
SEMICOLON
RETURN
IDENT fibonacci
L_PAREN
IDENT k
SUB
NUMBER 1
R_PAREN
ADD
IDENT fibonacci
L_PAREN
IDENT k
SUB
NUMBER 2
R_PAREN
SEMICOLON
END_BODY
FUNCTION
IDENT main
SEMICOLON
BEGIN_PARAMS
END_PARAMS
BEGIN_LOCALS
IDENT n
COLON
INTEGER
SEMICOLON
IDENT fib_n
COLON
INTEGER
SEMICOLON
END_LOCALS
BEGIN_BODY
READ
IDENT n
SEMICOLON
IDENT fib_n
ASSIGN
IDENT fibonacci
L_PAREN
IDENT n
R_PAREN
SEMICOLON
WRITE
IDENT fib_n
SEMICOLON
END_BODY


Detailed Requirements
The following tasks will need to be performed to complete this phase of the project.
First, you will need to write the grammar for the MINI-L language, based on the specification for MINI-L that we have provided for you. You must submit this grammar along with the other files required for this phase of the class project!
Create the bison parser specification file using the MINI-L grammar. Ensure that you specify helpful syntax error messages to be outputted by the parser in the event of any syntax errors.
Example: write the bison specification in a file named mini_l.y.
Run bison to generate the parser for MINI-L using your specification. The -d flag is necessary to create a .h file that will link your flex lexical analyzer and your bison parser. The -v flag is helpful for creating an output file that can be used to analyze any conflicts in bison. The --file-prefix option can be used to change the prefix of the file names outputted by bison.
Example: execute the command bison -v -d --file-prefix=y mini_l.y. This will create the parser in a file called y.tab.c, the necessary .h file called y.tab.h, and the informative output file called y.output.
Ensure that your MINI-L lexical analyzer from the first phase of the class project has been constructed.
Example: if your lexical analyzer specification is in a file called mini_l.lex, then use it with flex as follows: flex mini_l.lex. This will create the lexical analyzer in a file called lex.yy.c.
Compile everything together into a single executable.
Example: compile your parser into the executable parser with the following command: gcc -o parser y.tab.c lex.yy.c -lfl. The program parser should now be available for use.

** Phase3
The mil_run MIL interpreter
We are providing an interpreter for MIL intermediate code (mil_run), which can be used to execute the MIL code generated by your code generator. The mil_run interpreter requires an input file to be specified that contains the MIL code that should be executed. For example, if you have MIL code contained in a file called mil_code.mil, then you can execute the MIL code with the following command:

mil_run mil_code.mil

If the MIL code itself requires some input data, this input data can be written to a file and then redirected to the executing MIL code. For example, if the input values are written to a text file called input.txt, then it can be passed to the executing MIL program as follows:

mil_run mil_code.mil < input.txt

The mil_run interpreter will generate a file called milRun.stat that contains some statistics about the MIL code that was just executed. You may ignore this file.

mil_run makes the following assumptions.

Each line in the MIL file contains at most one MIL instruction
Each line is at most 254 characters long
All variables are defined before they are used
You must ensure that your generated MIL code meets the above three requirements.

mil_run is a linux executable and can be run on bolt.

Detailed Requirements
The following tasks will need to be performed to complete this phase of the project.
You will need to modify your bison specification file from the previous phase of the class project so that it no longer outputs the list of productions taken during parsing.
Implement the code generator. This will most likely require some enhancements to your bison specification file. You may also want to create additional implementation files. The requirements for your implementation are as follows.
You do not need to do anything special to handle lexical or syntax errors in this phase of the class project. If any lexical or syntax errors are encountered, your compiler should emit appropriate error message(s) and terminate the same way as was done in previous phases.
You need to check for semantic errors in the inputted MINI-L program. During code generation, if any semantic errors are encountered, then appropriate error messages should be emitted and no other output should be produced (i.e., no code should be generated).
If no semantic errors are encountered, then the appropriate MIL intermediate code should be generated and written to stdout.
When generating the intermediate code, be careful that you do not accidentally create a temporary variable with the same name as one of the variables specified in the original MINI-L program.
Compile everything together into a single executable. The particular commands needed to compile your code generator will depend on the implementation files you create.
Use the mil_run MIL interpreter to test your implementation. For each program written in MINI-L source code, compile it down to MIL code using your implementation. Then invoke the MIL code using mil_run to verify that the compiled program behaves as expected.
A Note about Runtime Errors
There are some errors that cannot always be captured at compile-time and may only happen at run-time. These errors include those such as array index out-of-bounds errors, and division by zero. Your implementation need not handle these errors. You may assume that when we grade your programs, we will not use any MINI-L programs that would lead to run-time errors. Note also that the mil_run MIL interpreter we are providing may have unexpected behavior if you try to run it on a program that can lead to run-time problems (such as an out-of-bounds array access). Thus, when you are testing your implementation, try to make sure your MINI-L programs will not cause any run-time errors.

Example Usage
Suppose your code generator is in the executable named my_compiler. Then for the MINI-L program fibonacci.min (which is syntactically and semantically correct), your code generator should be invoked as follows:

cat fibonacci.min | my_compiler

The file fibonacci.mil should then be created and should contain the generated MIL code (it is okay if your generated code looks slightly different, but it should have the same behavior when executed). Next, you can test your generated code using the mil_run MIL interpreter to ensure that it behaves as expected. Suppose we want to run the compiled fibonacci program with input "5":

echo 5 > input.txt
mil_run fibonacci.mil < input.txt
When the compiled fibonacci program is executed with the above input "5", then the fifth fibonacci number is printed to the screen:
The following tasks will need to be performed to complete this phase of the project.
Write the specification for a flex lexical analyzer for the MINI-L language. For this phase of the project, your lexical analyzer need only output the list of tokens identified from an inputted MINI-L program.
Example: write the flex specification in a file named mini_l.lex.
Run flex to generate the lexical analyzer for MINI-L using your specification.
Example: execute the command flex mini_l.lex. This will create a file called lex.yy.c in the current directory.
Compile your MINI-L lexical analyzer. This will require the -lfl flag for gcc.
Example: compile your lexical analyzer into the executable lexer with the following command: gcc -o lexer lex.yy.c -lfl. The program lexer should now be able to convert an inputted MINI-L program into the corresponding list of tokens.

** Phase II
Include:mini_l.lex /mini_l.y /mini_l_gramar.pdf /Makefile

CFLAGS = -g -Wall -ansi -pedantic

parser: mini_l.lex mini_l.y
	bison -v -d --file-prefix=y mini_l.y
	flex mini_l.lex
	gcc -o parser y.tab.c lex.yy.c -lfl

